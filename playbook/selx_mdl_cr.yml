---
- name: checking selinux unconfined service
  hosts: all
  remote_user: opsadmin
  become: true
  tasks:
    - name: checking conconfined services on server
      ansible.builtin.shell: ps -efZ | grep "unconfined_service_t" | grep -v grep|awk '{print $NF}'
      register: unconfined_check
      failed_when: false
      changed_when: false
    - name: displaying unconfined service running on server
      ansible.builtin.debug:
        msg: "Unconfined: {{ unconfined_check.stdout.split() }}"
      when: unconfined_check.stdout
    - name: Get names of unconfined service units
      ansible.builtin.shell: ps -eZ | grep 'unconfined_service_t' | awk '{print $2}' | xargs -r ps -o unit= -p
      register: unconfined_units
      changed_when: false
      failed_when: false
    - name: Create directories for each unconfined service
      ansible.builtin.file:
        path: "/root/admin/selx_cutm_policy/{{ item }}"
        state: directory
        mode: '0755'
        owner: root
        group: root
      loop: "{{ unconfined_units.stdout_lines }}"
      when: unconfined_units.stdout | trim | length > 0
    - name: Generate SELinux policy templates for each service
      ansible.builtin.shell: |
        EXEC_PATH=$(systemctl show -p ExecStart --value "{{ item }}" | awk '{print $1}' | sed 's/path=//;s/;//')
        CLEAN_NAME=$(echo "{{ item }}" | sed 's/\.service//;s/[^a-zA-Z0-9]/_/g')
        sepolicy generate --init -n $CLEAN_NAME $EXEC_PATH
      args:
        chdir: "/root/admin/selx_cutm_policy/{{ item }}"
        creates: "/root/admin/selx_cutm_policy/{{ item }}/{{ item | regex_replace('[^a-zA-Z0-9]', '_') | regex_replace('_service$', '') }}.te"
      loop: "{{ unconfined_units.stdout_lines }}"
      when: unconfined_units.stdout | trim | length > 0
    - name: Check if SELinux module is already loaded
      ansible.builtin.shell: |
        CLEAN_NAME=$(echo "{{ item }}" | sed 's/\.service//;s/[^a-zA-Z0-9]/_/g')
        /usr/sbin/semodule -lfull | grep -w "^${CLEAN_NAME}
      register: module_exists
      failed_when: false
      changed_when: false
      loop: "{{ unconfined_units.stdout_lines }}"
    - name: Stop play if module already exists (to prevent overwrite) 
      ansible.builtin.fail:
        msg: "The SELinux module for {{ item.item }} is already loaded. Stopping to prevent corruption."
      when: item.rc == 0
      loop: "{{ module_exists.results }}"
    - name: Compile and Install SELinux policies
      ansible.builtin.shell: |
        CLEAN_NAME=$(echo "{{ item }}" | sed 's/\.service//;s/[^a-zA-Z0-9]/_/g')
        # Compile
        make -f /usr/share/selinux/devel/Makefile ${CLEAN_NAME}.pp || exit 1
        # Install
        /usr/sbin/semodule -i ${CLEAN_NAME}.pp
      args:
        chdir: "/root/admin/selx_cutm_policy/{{ item }}"
      loop: "{{ unconfined_units.stdout_lines }}"
    - name: Parse TE file for the specific daemon domain
      ansible.builtin.shell: |
        ansible.builtin.shell: |
        CLEAN_NAME=$(echo "{{ item }}" | sed 's/\.service//;s/[^a-zA-Z0-9]/_/g')
        grep "init_daemon_domain" ${CLEAN_NAME}.te | awk '{print $2}' | tr -d '(),'
      args:
        chdir: "/root/admin/selx_cutm_policy/{{ item }}"
      register: daemon_domain_output
      loop: "{{ unconfined_units.stdout_lines }}"
      changed_when: false
    - name: Apply SELinux contexts and Relabel
      ansible.builtin.shell: |
        DOMAIN_TYPE="{{ item.stdout | trim }}"
        EXEC_PATH=$(systemctl show -p ExecStart --value "{{ item.item }}" | awk '{print $1}' | sed 's/path=//;s/;//')
        /usr/sbin/semanage fcontext -a -t "$DOMAIN_TYPE" "$EXEC_PATH" || \
        /usr/sbin/semanage fcontext -m -t "$DOMAIN_TYPE" "$EXEC_PATH"
        /sbin/restorecon -v "$EXEC_PATH"
      loop: "{{ daemon_domain_output.results }}"
      when: item.stdout | length > 0
      notify: "Restart unconfined services"
      
